# Implementation Plan: LXC Port Proxy

**Branch**: `002-port-proxy` | **Date**: 2026-02-11 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-port-proxy/spec.md`

## Summary

Add a `proxy` subcommand to `dilxc.sh` that lets users forward TCP ports from the LXC container to the host using LXD proxy devices (`lxc config device add/show/remove`). This enables container services (web servers, Docker containers) to be reached from other machines on the LAN. The implementation adds ~150 lines of bash to a single file (`dilxc.sh`) following the existing command pattern: a top-level `cmd_proxy` function with nested dispatch to `add`, `list`/`ls`, `rm`/`remove`, and `--help` sub-actions.

## Technical Context

**Language/Version**: Bash (GNU Bash, Ubuntu 24.04 default)
**Primary Dependencies**: LXD (`lxc` CLI) — already required by the project
**Storage**: LXD's internal database (proxy devices are container config, not files)
**Testing**: Acceptance tests via `bats` or shell-based test scripts against a live container
**Target Platform**: Ubuntu homelab server (host side only)
**Project Type**: Single script modification (`dilxc.sh`)
**Performance Goals**: Sub-second command execution (LXC commands complete in <1s)
**Constraints**: No external dependencies beyond `lxc` CLI; pure bash parsing of YAML output
**Scale/Scope**: One file modified, ~5 new functions, ~150 lines added

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Shell Scripts Only | PASS | Pure bash added to existing script. No new tools/frameworks. |
| II. Three Scripts, Three Contexts | PASS | All changes in `dilxc.sh` (host-side management script). No new scripts. |
| III. Readability Wins Over Cleverness | PASS | Simple case dispatch, explicit variable names, no chained pipelines. YAML parsing uses straightforward awk, not one-liner magic. |
| IV. Container Is the Sandbox | N/A | Feature doesn't affect sandbox security model. |
| V. Don't Touch the Host | PASS | All `lxc` commands scoped to `$CONTAINER_NAME`. No host-level config changes. |
| VI. LXD Today, Incus Eventually | PASS | Uses `lxc config device add/show/remove` — identical syntax in Incus. No LXD-specific features used. |
| VII. Idempotent Provisioning | N/A | No changes to provisioning. |
| VIII. Detect and Report, Don't Auto-Fix | PASS | Duplicate detection reports the conflict; LXD bind failures are relayed with a hint. No silent retries. |
| IX. Shell Parity: Bash/Fish | N/A | No changes to shell configs inside container. |
| X. Error Handling | PASS | `dilxc.sh` does not use `set -e`; each command handles failures individually. |
| XI. Rsync Excludes Sync | N/A | No rsync changes. |
| XII. Keep Arguments Safe | PASS | Port numbers are validated as integers before use. No user-provided strings passed through shell expansion. |

**Gate result**: PASS — no violations.

## Project Structure

### Documentation (this feature)

```text
specs/002-port-proxy/
├── plan.md              # This file
├── research.md          # LXC proxy device research & decisions
├── data-model.md        # Proxy device schema & naming convention
├── quickstart.md        # User-facing usage guide
├── contracts/
│   └── proxy.md         # CLI contract: commands, output, errors
└── tasks.md             # (Phase 2 — generated by /speckit.tasks)
```

### Source Code (repository root)

```text
dilxc.sh                 # The only file modified
```

**Structure Decision**: This is a single-file modification. No new source files, directories, or modules are needed. All new functions are added to `dilxc.sh` following the existing `cmd_<name>` pattern. The feature adds:

- `proxy_usage()` — help text for the proxy subcommand
- `validate_port()` — shared port validation helper
- `cmd_proxy_add()` — create a proxy device
- `cmd_proxy_list()` — list proxy devices (parses YAML)
- `cmd_proxy_rm()` — remove one or all proxy devices
- `cmd_proxy()` — top-level dispatcher with nested case

Plus: one new entry in the main dispatch case block and one new line in the `usage()` function.

## Implementation Approach

### Step 1: Add port validation helper

A `validate_port` function that checks a value is a non-empty integer in range 1-65535. Used by both `add` and `rm`. Prints a clear error and exits 1 on failure.

### Step 2: Add `proxy add` command

Creates an LXC proxy device with naming convention `proxy-tcp-<host-port>`. Validates inputs, checks for duplicates via device name lookup, calls `lxc config device add`, prints confirmation.

### Step 3: Add `proxy list` command

Runs `lxc config device show` and parses the YAML output with awk. Filters for `proxy-tcp-*` devices, extracts `listen` and `connect` fields, displays a clean table. Uses `require_container` (not `require_running`) so it works on stopped containers.

### Step 4: Add `proxy rm` command

Removes a single proxy device by host port, or all proxy devices when given `all`. Validates port input, checks device exists, calls `lxc config device remove`.

### Step 5: Add help text and dispatch

- `proxy_usage()` function with synopsis, actions, and examples
- `cmd_proxy()` dispatcher with nested case for sub-actions
- New entry in main dispatch: `proxy) shift; cmd_proxy "$@" ;;`
- New line in `usage()` function listing the proxy command

### Step 6: Acceptance testing

Test all scenarios from the spec against a live container:
1. Add proxy (same port, different ports)
2. List proxies (with proxies, without proxies)
3. Remove proxy (single, all, nonexistent)
4. Edge cases (invalid ports, duplicate add, no args, stopped container list)

## Complexity Tracking

No constitution violations to justify. The implementation is a straightforward addition to an existing script following established patterns.
